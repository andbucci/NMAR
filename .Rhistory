}else if(st_type == 'autoregressive'){
st = rep(0, (nsim+p))
epsilonst = rnorm((nsim+p))
st[1] = epsilonst[1]
for(t in 2:nsim){
st[t] = 0.95 * st[(t-1)] + epsilonst[t]
}
st = st[1:(length(st)-1)]
}
index = list()
for(i in 1:regimes){
if(i == 1){
index[[i]] =  rep(1, nsim)
index[[i]][st >= threshold[i]] = 0
}else if(i > 1 & i != regimes){
index[[i]] =  rep(0, nsim)
index[[i]][st >= threshold[(i-1)] & st < threshold[i]] = 1
}else{
index[[i]] =  rep(1, nsim)
index[[i]][st < threshold[(i-1)]] = 0
}
}
Xt = array(0, dim = c(m,n,(nsim+1)))
Xt[,,1:p] = M[[1]]
for(t in (1+p):nsim){
if(Etype == 'identity'){
Et = matrixNormal::rmatnorm(M = matrix(0, m, n), U=sdEt*diag(m), V=sdEt*diag(n))
}else if(Etype == 'normal'){
Et = matrix(rnorm(m*n,mean=0,sd=sdEt), m, n)
}
Xreg = matrix(0, m, n)
for(i in 1:regimes){
Xval = matrix(0, m, n)
for(k in 1:p){
Xval = A[[k]][[i]]%*%Xt[,,(t-k)]%*%t(B[[k]][[i]]) + Xval
}
if(constant == TRUE){
Xreg = (M[[i]] + Xval + Et)*index[[i]][t] + Xreg
}else{
Xreg = (Xval + Et)*index[[i]][t] + Xreg
}
}
Xt[,,t] = Xreg
}
Xt = Xt[,,p:nsim]
xtvec = matrix(nrow = nsim, ncol = m*n)
for(l in 1:nsim){
xtvec[l,] <- matrixcalc::vec(Xt[,,l])
}
simuldata = list(data = Xt, st = st[(p+1):nsim], threshold  = threshold, datavec = xtvec)
return(simuldata)
}
A = list(list(matrix(0.05, m, m), matrix(0.10, m, m), matrix(0.12, m, m)))
B = list(list(matrix(0.05, n, n), matrix(0.10, n, n), matrix(0.12, n, n)))
M = list(matrix(1, m, n), matrix(1.5, m, n), matrix(2, m, n))
simuldata = MTAR.sim(m=m, n=n, p = 1,nsim = 1000,
regimes = 3, threshold = c(0.3, 0.7), st_type = 'trend', Etype = 'normal', A = A, B= B, M = M, sdEt = 0.1)
plot.ts(simuldata$data[1,1,])
library(sparsevar)
spectralRadius(kronecker(A[[1]], B[[1]]))
spectralRadius(kronecker(A[[1]][[1]], B[[1]][[1]]))
spectralRadius(kronecker(A[[1]][[2]], B[[1]][[2]]))
spectralRadius(kronecker(A[[1]][[3]], B[[1]][[2]]))
spectralRadius(kronecker(A[[1]][[4]], B[[1]][[4]]))
A[[1]][[3]]
B[[1]][[3]]
plot.ts(simuldata$data[1,1,])
MTAR.sim <- function(m = 2, n = 3, p = 1, regimes = 2, nsim = 1000,
constant = TRUE, A, B, M = NULL, threshold = 0.3,
st_type = c('trend', 'autoregressive'), Etype=c('identity','normal'),
sdEt = 0.2){
if(regimes < 2)
stop('The number of regimes should be greater than one.')
if(length(threshold) != (regimes-1))
stop('The number of thresholds should be equal to the number of transitions.')
if(st_type == 'trend'){
st = rep(0, (nsim+p))
st = (1:nsim)/nsim
index1 = rep(0, nsim)
index2 = rep(0, nsim)
}else if(st_type == 'autoregressive'){
st = rep(0, (nsim+p))
epsilonst = rnorm((nsim+p))
st[1] = epsilonst[1]
for(t in 2:nsim){
st[t] = 0.95 * st[(t-1)] + epsilonst[t]
}
st = st[1:(length(st)-1)]
}
index = list()
for(i in 1:regimes){
if(i == 1){
index[[i]] =  rep(1, nsim)
index[[i]][st >= threshold[i]] = 0
}else if(i > 1 & i != regimes){
index[[i]] =  rep(0, nsim)
index[[i]][st >= threshold[(i-1)] & st < threshold[i]] = 1
}else{
index[[i]] =  rep(1, nsim)
index[[i]][st < threshold[(i-1)]] = 0
}
}
Xt = array(0, dim = c(m,n,(nsim+1)))
Xt[,,1:p] = M[[1]]
for(t in (1+p):nsim){
if(Etype == 'identity'){
Et = matrixNormal::rmatnorm(M = matrix(0, m, n), U=sdEt*diag(m), V=sdEt*diag(n))
}else if(Etype == 'normal'){
Et = matrix(rnorm(m*n,mean=0,sd=sdEt), m, n)
}
Xreg = matrix(0, m, n)
for(i in 1:regimes){
Xval = matrix(0, m, n)
for(k in 1:p){
Xval = A[[k]][[i]]%*%Xt[,,(t-k)]%*%t(B[[k]][[i]]) + Xval
}
if(constant == TRUE){
Xreg = (M[[i]] + Xval + Et)*index[[i]][t] + Xreg
}else{
Xreg = (Xval + Et)*index[[i]][t] + Xreg
}
}
Xt[,,t] = Xreg
}
Xt = Xt[,,p:nsim]
xtvec = matrix(nrow = nsim, ncol = m*n)
for(l in 1:nsim){
xtvec[l,] <- matrixcalc::vec(Xt[,,l])
}
simuldata = list(data = Xt, st = st[(p+1):nsim], threshold  = threshold, datavec = xtvec)
return(simuldata)
}
A = list(list(matrix(0.05, m, m), matrix(0.10, m, m), matrix(0.12, m, m)))
B = list(list(matrix(0.05, n, n), matrix(0.10, n, n), matrix(0.12, n, n)))
M = list(matrix(1, m, n), matrix(1.5, m, n), matrix(2, m, n))
simuldata = MTAR.sim(m=m, n=n, p = 1,nsim = 1000,
regimes = 3, threshold = c(0.3, 0.7), st_type = 'trend', Etype = 'normal', A = A, B= B, M = M, sdEt = 0.1)
plot.ts(simuldata$data[1,1,])
#'fit.MTAR <- MTAR(simuldata$data, regimes = 3, maxiter = 30, st = simuldata$st,
#'initA = initA, initB = initB, initM = initM, q = 0.1,
#'verbose = F, ncores = 4)
#'# a few methods for VLSTAR
#'print(fit.MTAR)
#'summary(fit.MTAR)
#'plot(fit.MTAR)
#'predict(fit.MTAR, st.new = 1, n.ahead = 1)
#'coef(fit.MTAR)}
#'
MTAR <- function(data, p = 1, regimes = 3, maxiter = 200, st, q = 0.10,
constant = TRUE, initA, initB, initM = NULL,
epsilon = 10^(-3), verbose = TRUE, ncores = 6){
chk <- Sys.getenv("_R_CHECK_LIMIT_CORES_", "")
if(is.null(ncores)){
if (nzchar(chk) && chk == "TRUE") {
# use 2 cores in CRAN/Travis/AppVeyor
ncores <- 2L
} else {
ncores <- parallel::detectCores()
}}
m = dim(data)[1]
n = dim(data)[2]
Tlength = dim(data)[3]
st = st
st_q = quantile(st, probs = seq(0.1,0.9,q))
message(paste('Alternative least square estimation of a MTAR\n'))
stq = expand.grid(rep(list(st_q), (regimes-1)))
stq1 = as.matrix(stq[rowSums(as.matrix(stq[,-ncol(stq)]) < stq[,-1]) == ncol(stq) - 1,])
colnames(stq1) = paste('c', rep(1:(regimes-1)), sep = '')
Alist = list()
Blist = list()
Mlist = list()
datalist = list()
errors = list()
Treg = rep(0, regimes)
QQ = rep(0, nrow(stq1))
pb <- txtProgressBar(0, nrow(stq1), style = 3)
for(i in 1:nrow(stq1)){
setTxtProgressBar(pb, i)
A = initA
B = initB
M = initM
for(j in 1:regimes){
if(j == 1){
datalist[[j]] = data[,,which(st < stq1[i,j])]
}else if(j > 1 & j != regimes){
datalist[[j]] = data[,,which(st >= stq1[i,(j-1)] & st < stq1[i, j])]
}else{
datalist[[j]] = data[,,which(st >= stq1[i,(j-1)])]
}
Treg[j] = dim(datalist[[j]])[3]
iter = 0
bdiff = matrix(1, nrow = n, ncol = n)
while(iter < maxiter & all(bdiff > epsilon)){
iter <- iter+1
for(k in 1:p){
seqex = 1:p
seqex = seqex[-k]
temp1A = matrix(0, nrow = m, ncol = m)
temp2A = matrix(0, nrow = m, ncol = m)
for(t in (p+1):Treg[j]){
temp3A = matrix(0, nrow = m, ncol = m)
for(l in seqex){
temp3A = A[[l]][[j]]%*%datalist[[j]][,,(t-l)]%*%t(B[[l]][[j]])%*%B[[k]][[j]]%*%t(data[,,(t-k)])+temp3A
}
if(constant == TRUE){
temp1A = datalist[[j]][,,t] %*%B[[k]][[j]]%*%t(datalist[[j]][,,(t-k)]) -
M[[j]]%*%B[[k]][[j]]%*%t(datalist[[j]][,,(t-k)]) - temp3A + temp1A
}else{
temp1A = (datalist[[j]][,,t] %*%B[[k]][[j]]%*%t(datalist[[j]][,,(t-k)])-temp3A) + temp1A
}
temp2A = (datalist[[j]][,,(t-k)]%*%t(B[[k]][[j]])%*%B[[k]][[j]]%*%t(datalist[[j]][,,(t-k)])) + temp2A
}
A[[k]][[j]] = frob.rescale(temp1A %*% MASS::ginv(temp2A))
}
for(k in 1:p){
seqex = 1:p
seqex = seqex[-k]
temp1B = matrix(0, nrow = n, ncol = n)
temp2B = matrix(0, nrow = n, ncol = n)
for(t in (p+1):Treg[j]){
temp3B = matrix(0, nrow = n, ncol = n)
for(l in seqex){
temp3B = B[[l]][[j]]%*%t(datalist[[j]][,,(t-l)])%*%t(A[[l]][[j]])%*%A[[k]][[j]]%*%data[,,(t-k)]+temp3B
}
if(constant == TRUE){
temp1B = t(datalist[[j]][,,t]-M[[j]]) %*%A[[k]][[j]]%*%datalist[[j]][,,(t-k)] - temp3B + temp1B
}else{
temp1B = t(datalist[[j]][,,t]) %*%A[[k]][[j]]%*%datalist[[j]][,,(t-k)] -temp3B + temp1B
}
temp2B = t(datalist[[j]][,,(t-k)])%*%t(A[[k]][[j]])%*%A[[k]][[j]]%*%datalist[[j]][,,(t-k)] + temp2B
}
Bcheck = temp1B %*% MASS::ginv(temp2B)
if(iter >1){
bdiff = abs(B[[k]][[j]] - Bcheck)
}
B[[k]][[j]] = temp1B %*% MASS::ginv(temp2B)
}
if(constant == TRUE){
temp1M = matrix(0, nrow = m, ncol = n)
for(t in (p+1):Treg[j]){
temp2M = matrix(0, nrow = m, ncol = n)
for(k in 1:p){
temp2M = A[[k]][[j]]%*%datalist[[j]][,,(t-k)]%*%t(B[[k]][[j]])
}
temp1M = datalist[[j]][,,t] - temp2M + temp1M
}
M[[j]] = temp1M/(Treg[j]-1)
}
if(verbose==TRUE){
print(iter)}
}
####Compute sum of squared residuals####
epsilon1 = matrix(0, nrow = Treg[j], ncol = m*n)
epsilon1m = matrix(0, ncol = m*n, nrow = m*n)
for(l in (p+1):Treg[j]){
epsilon2 = matrix(0, nrow = m, ncol = n)
for(k in 1:p){
epsilon2 = A[[k]][[j]]%*%datalist[[j]][,,(l-k)]%*%t(B[[k]][[j]])+epsilon2
}
if(constant == TRUE){
epsilon1[l,] = matrixcalc::vec(datalist[[j]][,,l] - M[[j]]- epsilon2)
}else{
epsilon1[l,] = matrixcalc::vec(datalist[[j]][,,l] - epsilon2)
}
epsilon1m = epsilon1[l,] %*% t(epsilon1[l,]) + epsilon1m
}
errors[[j]] = epsilon1m
}
Alist[[i]] = A
Blist[[i]] = B
if(constant == TRUE){
Mlist[[i]] = M
}
errlist = lapply(errors, tr)
QQ[i] = Reduce("+", errlist)
if(verbose==TRUE){
cat(paste(i, 'th', ' combination', sep = ''))}
Sys.sleep(time = 1)
}
close(pb)
if(constant == TRUE){
theta <- list(A = Alist[[which.min(QQ)]], B = Blist[[which.min(QQ)]],
M = Mlist[[which.min(QQ)]],
c = t(as.matrix(stq1[which.min(QQ),])))
}else{
theta <- list(A = Alist[[which.min(QQ)]], B = Blist[[which.min(QQ)]],
c = t(as.matrix(stq1[which.min(QQ),])))
}
stationary_A <- rapply(theta$A, sparsevar::spectralRadius)
stationary_B <- rapply(theta$B, sparsevar::spectralRadius)
stat_check = (Reduce("*", stationary_A)*Reduce("*", stationary_B))<1
index = list()
for(i in 1:regimes){
if(i == 1){
index[[i]] =  which(st < theta$c[1,i])
}else if(i > 1 & i != regimes){
index[[i]] =  which(st >= theta$c[1,(i-1)] & st < theta$c[1,i])
}else{
index[[i]] =  which(st >= theta$c[1,(i-1)])
}
}
fit.val = array(data = NA, dim = c(m,n,Tlength))
res.val = array(data = NA, dim = c(m,n,Tlength))
xvec = matrix(NA, nrow = Tlength, ncol = m*n)
Sigma = matrix(0, nrow = m*n, ncol = m*n)
for(i in (p+1):Tlength){
for(j in 1:regimes){
if(i %in% index[[j]]){
fittmp = matrix(0, nrow = m, ncol = n)
for(k in 1:p){
fittmp = theta$A[[k]][[j]]%*%data[,,(i-k)]%*%t(theta$B[[k]][[j]])
}
if(constant == TRUE){
fit.val[,,i] = theta$M[[j]] + fittmp
}else{
fit.val[,,i] = fittmp
}
}
}
res.val[,,i] = data[,,i] - fit.val[,,i]
Sigma = Sigma + matrixcalc::vec(res.val[,,i]) %*% t(matrixcalc::vec(res.val[,,i]))
xvec[i,] = matrixcalc::vec(data[,,(i-1)])
}
Omega = Sigma/(Tlength-1L)
Sigmar = list()
Sigmar2 = list()
for(j in 1:regimes){
dfperm = aperm(data[,,index[[j]]], c(3,1,2))
for(k in 1:p){
Sigmar2[[k]] = covtosd(Sigma, c(m,n), R = 1, p = 1, A = list(theta$A[[k]][[j]], theta$B[[k]][[j]]),
AX = dfperm[-1,,])
}
Sigmar[[j]] = Sigmar2
}
# for(s in 1:pred.step){
#   tensor[,,(T1+s)] = iterations[[maxiter]]$A %*% tensor[,,(T+s-1)] %*% t(iterations[[maxiter]]$B)
# }
# predictions = tensor[,,((T1+1):(T1+pred.step))]
if(constant == TRUE){
results = list(stationary = stat_check, A = theta$A,
B = theta$B, M = theta$M, threshold = theta$c, Sigma = Omega,
stderr = Sigmar, fitted = fit.val, residuals = res.val,
dimensions = lapply(index, length))
}else{
results = list(stationary = stat_check, A = theta$A,
B = theta$B,  threshold = theta$c, Sigma = Omega,
stderr = Sigmar, fitted = fit.val, residuals = res.val,
dimensions = lapply(index, length))
}
return(results)
}
fit.MTAR <- MTAR(simuldata$data, regimes = 3, maxiter = 30, st = simuldata$st,
initA = initA, initB = initB, initM = initM, q = 0.1,
verbose = F, ncores = 4)
initA = list(list(diag(rep(0.05,m)), diag(rep(0.05,m)), diag(rep(0.05,m))))
initB = list(list(diag(rep(0.05,n)), diag(rep(0.05,n)), diag(rep(0.05,n))))
initM = list(matrix(1, m, n), matrix(1, m, n), matrix(1, m, n))
fit.MTAR <- MTAR(simuldata$data, regimes = 3, maxiter = 30, st = simuldata$st,
initA = initA, initB = initB, initM = initM, q = 0.1,
verbose = F, ncores = 4)
####Trace of a matrix####
tr <- function(A) {
n <- dim(A)[1] # get dimension of matrix
tr <- 0 # initialize trace value
# Loop over the diagonal elements of the supplied matrix and add the element to tr
for (k in 1:n) {
l <- A[k,k]
tr <- tr + l
}
return(tr[[1]])
}
####Frobenius distance between two matrices####
Frob <- function(A, B){
D = A-B
d = sqrt(tr(t(D)%*%D))
return(d)
}
####Sum of squared residuals for the MSTAR####
SSQ <- function(param, data){
datalist = data
Y <- datalist$Y
m = dim(Y)[1]
n = dim(Y)[2]
gamma <- param[1]
c <- param[2]
dify <- matrix(0, ncol = m*n, nrow = m*n)
for(z in 2:dim(Y)[3]){
g = (1/(1 + exp(-gamma*(datalist$st[(z-1)]-c))))
dify = matrixcalc::vec(datalist$Y[,,z] - datalist$A %*% datalist$Y[,,(z-1)]%*%t(datalist$B) - g*datalist$C%*%datalist$Y[,,(z-1)]%*%t(datalist$D))%*%
t(matrixcalc::vec(datalist$Y[,,z] - datalist$A %*% datalist$Y[,,(z-1)]%*%t(datalist$B) - g*datalist$C%*%datalist$Y[,,(z-1)]%*%t(datalist$D)))+dify
}
tracemin = tr(dify)
return(tracemin)
}
####From estimated covariance matrix to standard errors####
covtosd <- function(Sigma, dim, R, p, A, AX){
pdim = prod(dim)
fdim = dim**2
ndim = sum(fdim)
K <- length(dim)
P <- length(R)
Tlength = dim(AX)[1]
Gamma <- matrix(0,sum(R)*ndim,sum(R)*ndim)
n = 0
for(i in c(1:p)){
for(j in c(1:R[i])){
for(k in c(1:(K-1))){
r1 <- matrix(0, sum(R)*ndim,1)
a1 <- as.vector(A[[k]])
r1[(n*ndim + sum(fdim[0:(k-1)]) + 1): (n*ndim + sum(fdim[0:k])),] = a1
Gamma = Gamma + r1 %*% t(r1)
if (K==2){
for (l in c(1:R[i])){
if (l != j){
r1 <- matrix(0, sum(r)*ndim, 1)
a = as.vector(A[[k]])
r1[(n*ndim + sum(fdim[0:(k-1)]) + 1): (n*ndim + sum(fdim[0:k])),] = a
Gamma = Gamma + r1 %*% t(r1)
}
}
}
}
n = n+1
}
}
WT = c(); Q = list(); perm = list(); size = list()
for (i in c(1:p)){
for (j in c(1:R[i])){
for (k in c(1:K)){
if (length(Q) < K){
perm[[k]] = c(k+1, (1:K)[-k] + 1, 1)
size[[k]] = c(dim[k], prod(dim[-k]), Tlength)
s = if (is.na(prod(dim[(k+1):K]))) 1 else prod(dim[(k+1):K])
Q[[k]] = kronecker(diag(s), pm(dim[k], prod(dim[0:(k-1)])))
}
# AXX = AX[[i]][[j]][[k]] # AXX = rTensor::ttl(xx, A.new[[i]][[j]][-k], c(2:(K+1))[-k])
AXX = abind::asub(AX, (2+p-i):(Tlength-i), 1, drop=FALSE)
AXfold = array(aperm(AXX, perm[[k]]), size[[k]])
AXI = apply(AXfold,3,function(x){kronecker(x, diag(dim[k])) %*% Q[[k]]})
AXI.array <- array(AXI,c(dim[k]^2,pdim,Tlength))
WT <- abind::abind(WT, AXI.array,along=1)
}
}
}
WT = aperm(WT, c(3,1,2))
WSigma <- tensor::tensor(WT,Sigma,3,1) #t*(d1^2+d2^2+d^3)*(d1d2d3)
EWSigmaWt <- tensor::tensor(WSigma,WT,c(3,1),c(3,1))/Tlength
H <- tensor::tensor(WT,WT,c(3,1),c(3,1))/Tlength + Gamma #r(d1^2+d2^2+d^2)*r(d1^2+d2^2+d^3)
Hinv <- solve(H)
cov <- Hinv %*% EWSigmaWt %*% Hinv
sd = list()
for (p in c(1:P)){
if (is.na(R[p])) stop("p != length(R)")
if (R[p] == 0) next
sd[[p]] <- lapply(1:R[p], function(j) {lapply(1:K, function(i) {list()})})
}
for (i in c(1:P)){
for (j in c(1:R[i])){
for (k in c(1:K)){
left <- sum(dim^2)*sum(R[0:(i-1)]) + sum(dim^2)*(j-1) + sum((dim^2)[1:(k-1)])+1
right <- sum(dim^2)*sum(R[0:(i-1)]) + sum(dim^2)*(j-1) + sum((dim^2)[1:k])
sd[[i]][[j]][[k]] <- array(sqrt(diag(cov)[left:right]), c(dim[k], dim[k]))
}
}
}
return(sd)
}
# Permutation matrix pm
pm <- function(m,n){
## m: an array of dimensions of matrices \eqn{A_1,A_2,\cdots,A_k}
## n: length of time
## return: Permutation matrix pm
mat <- matrix(0,m*n,m*n)
for (i in c(1:n)){
for (j in c(1:m)){
mat <- mat + kronecker(em(n,m,i,j),t(em(n,m,i,j)))
}
}
return(mat)
}
# Permutation matrix em
em <- function(m,n,i,j){
## m,n,i,j set \eqn{m \times n} zero matrix with \eqn{A_{ij} = 1}
## return: Permutation matrix em such that \eqn{A_{ij} = 1} and other entries equals 0.
mat <- matrix(0,m,n)
mat[i,j] <- 1
return(mat)
}
####Frobenius rescale for the matrices in A####
frob.rescale <- function(A){
m = A
nrm = norm(m, 'f')
Anorm = m/nrm
return(Anorm)
}
initA = list(list(diag(rep(0.05,m)), diag(rep(0.05,m)), diag(rep(0.05,m))))
initB = list(list(diag(rep(0.05,n)), diag(rep(0.05,n)), diag(rep(0.05,n))))
initM = list(matrix(1, m, n), matrix(1, m, n), matrix(1, m, n))
fit.MTAR <- MTAR(simuldata$data, regimes = 3, maxiter = 30, st = simuldata$st,
initA = initA, initB = initB, initM = initM, q = 0.1,
verbose = F, ncores = 4)
fit.MTAR$threshold
fit.MTAR$A
fit.MTAR$M
fit.MTAR$B
getwd()
setwd()
setwd("C:/Users/andre/Documents/NMAR")
roxygen2::roxygenise()
rm(MTAR)
rm(MTAR.sim)
roxygen2::roxygenise()
